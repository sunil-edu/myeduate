// Copyright 2021-present Eduate Pvt Ltd. All rights reserved.
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"myeduate/ent/msgchannelmessage"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// MsgChannelMessage is the model entity for the MsgChannelMessage schema.
type MsgChannelMessage struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// MsgDate holds the value of the "msg_date" field.
	MsgDate *time.Time `json:"msg_date,omitempty"`
	// MsgIsExpiry holds the value of the "msg_is_expiry" field.
	MsgIsExpiry bool `json:"msg_is_expiry,omitempty"`
	// MsgExpiryDate holds the value of the "msg_expiry_date" field.
	MsgExpiryDate *time.Time `json:"msg_expiry_date,omitempty"`
	// MsgIsText holds the value of the "msg_is_text" field.
	MsgIsText bool `json:"msg_is_text,omitempty"`
	// MsgContent holds the value of the "msg_content" field.
	MsgContent string `json:"msg_content,omitempty"`
	// MsgMediaType holds the value of the "msg_media_type" field.
	MsgMediaType string `json:"msg_media_type,omitempty"`
	// MsgMediaContent holds the value of the "msg_media_content" field.
	MsgMediaContent string `json:"msg_media_content,omitempty"`
	// MsgActive holds the value of the "msg_active" field.
	MsgActive bool `json:"msg_active,omitempty"`
	// MsgIsIndividual holds the value of the "msg_is_individual" field.
	MsgIsIndividual bool `json:"msg_is_individual,omitempty"`
	// MsgRecvOrSent holds the value of the "msg_recv_or_sent" field.
	MsgRecvOrSent string `json:"msg_recv_or_sent,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*MsgChannelMessage) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case msgchannelmessage.FieldMsgIsExpiry, msgchannelmessage.FieldMsgIsText, msgchannelmessage.FieldMsgActive, msgchannelmessage.FieldMsgIsIndividual:
			values[i] = new(sql.NullBool)
		case msgchannelmessage.FieldID:
			values[i] = new(sql.NullInt64)
		case msgchannelmessage.FieldMsgContent, msgchannelmessage.FieldMsgMediaType, msgchannelmessage.FieldMsgMediaContent, msgchannelmessage.FieldMsgRecvOrSent:
			values[i] = new(sql.NullString)
		case msgchannelmessage.FieldCreatedAt, msgchannelmessage.FieldUpdatedAt, msgchannelmessage.FieldMsgDate, msgchannelmessage.FieldMsgExpiryDate:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type MsgChannelMessage", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the MsgChannelMessage fields.
func (mcm *MsgChannelMessage) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case msgchannelmessage.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			mcm.ID = int(value.Int64)
		case msgchannelmessage.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				mcm.CreatedAt = value.Time
			}
		case msgchannelmessage.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				mcm.UpdatedAt = value.Time
			}
		case msgchannelmessage.FieldMsgDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field msg_date", values[i])
			} else if value.Valid {
				mcm.MsgDate = new(time.Time)
				*mcm.MsgDate = value.Time
			}
		case msgchannelmessage.FieldMsgIsExpiry:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field msg_is_expiry", values[i])
			} else if value.Valid {
				mcm.MsgIsExpiry = value.Bool
			}
		case msgchannelmessage.FieldMsgExpiryDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field msg_expiry_date", values[i])
			} else if value.Valid {
				mcm.MsgExpiryDate = new(time.Time)
				*mcm.MsgExpiryDate = value.Time
			}
		case msgchannelmessage.FieldMsgIsText:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field msg_is_text", values[i])
			} else if value.Valid {
				mcm.MsgIsText = value.Bool
			}
		case msgchannelmessage.FieldMsgContent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field msg_content", values[i])
			} else if value.Valid {
				mcm.MsgContent = value.String
			}
		case msgchannelmessage.FieldMsgMediaType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field msg_media_type", values[i])
			} else if value.Valid {
				mcm.MsgMediaType = value.String
			}
		case msgchannelmessage.FieldMsgMediaContent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field msg_media_content", values[i])
			} else if value.Valid {
				mcm.MsgMediaContent = value.String
			}
		case msgchannelmessage.FieldMsgActive:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field msg_active", values[i])
			} else if value.Valid {
				mcm.MsgActive = value.Bool
			}
		case msgchannelmessage.FieldMsgIsIndividual:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field msg_is_individual", values[i])
			} else if value.Valid {
				mcm.MsgIsIndividual = value.Bool
			}
		case msgchannelmessage.FieldMsgRecvOrSent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field msg_recv_or_sent", values[i])
			} else if value.Valid {
				mcm.MsgRecvOrSent = value.String
			}
		}
	}
	return nil
}

// Update returns a builder for updating this MsgChannelMessage.
// Note that you need to call MsgChannelMessage.Unwrap() before calling this method if this MsgChannelMessage
// was returned from a transaction, and the transaction was committed or rolled back.
func (mcm *MsgChannelMessage) Update() *MsgChannelMessageUpdateOne {
	return (&MsgChannelMessageClient{config: mcm.config}).UpdateOne(mcm)
}

// Unwrap unwraps the MsgChannelMessage entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (mcm *MsgChannelMessage) Unwrap() *MsgChannelMessage {
	tx, ok := mcm.config.driver.(*txDriver)
	if !ok {
		panic("ent: MsgChannelMessage is not a transactional entity")
	}
	mcm.config.driver = tx.drv
	return mcm
}

// String implements the fmt.Stringer.
func (mcm *MsgChannelMessage) String() string {
	var builder strings.Builder
	builder.WriteString("MsgChannelMessage(")
	builder.WriteString(fmt.Sprintf("id=%v", mcm.ID))
	builder.WriteString(", created_at=")
	builder.WriteString(mcm.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(mcm.UpdatedAt.Format(time.ANSIC))
	if v := mcm.MsgDate; v != nil {
		builder.WriteString(", msg_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", msg_is_expiry=")
	builder.WriteString(fmt.Sprintf("%v", mcm.MsgIsExpiry))
	if v := mcm.MsgExpiryDate; v != nil {
		builder.WriteString(", msg_expiry_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", msg_is_text=")
	builder.WriteString(fmt.Sprintf("%v", mcm.MsgIsText))
	builder.WriteString(", msg_content=")
	builder.WriteString(mcm.MsgContent)
	builder.WriteString(", msg_media_type=")
	builder.WriteString(mcm.MsgMediaType)
	builder.WriteString(", msg_media_content=")
	builder.WriteString(mcm.MsgMediaContent)
	builder.WriteString(", msg_active=")
	builder.WriteString(fmt.Sprintf("%v", mcm.MsgActive))
	builder.WriteString(", msg_is_individual=")
	builder.WriteString(fmt.Sprintf("%v", mcm.MsgIsIndividual))
	builder.WriteString(", msg_recv_or_sent=")
	builder.WriteString(mcm.MsgRecvOrSent)
	builder.WriteByte(')')
	return builder.String()
}

// MsgChannelMessages is a parsable slice of MsgChannelMessage.
type MsgChannelMessages []*MsgChannelMessage

func (mcm MsgChannelMessages) config(cfg config) {
	for _i := range mcm {
		mcm[_i].config = cfg
	}
}
